"""autogenerated by genpy from neato_mudd/NeatoSensors.msg. Do not edit."""
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import std_msgs.msg

class NeatoSensors(genpy.Message):
  _md5sum = "9cb831733caf587061ba74aa287e0e35"
  _type = "neato_mudd/NeatoSensors"
  _has_header = True #flag to mark the presence of a Header object
  _full_text = """Header header
int16 WallSensorInMM
int16 BatteryVoltageInmV
int16 LeftDropInMM
int16 RightDropInMM
int8 RightMagSensor
int8 LeftMagSensor
bool SNSR_DC_JACK_CONNECT
bool SNSR_DUSTBIN_IS_IN
bool SNSR_LEFT_WHEEL_EXTENDED
bool SNSR_RIGHT_WHEEL_EXTENDED
bool LSIDEBIT
bool LFRONTBIT
bool RSIDEBIT
bool RFRONTBIT
bool BTN_SOFT_KEY
bool BTN_SCROLL_UP
bool BTN_SCROLL_DOWN
bool BTN_START
bool BTN_BACK
int32 LeftWheel_Encoder
int32 LeftWheel_PositionInMM
int16 LeftWheel_RPM
int32 RightWheel_Encoder
int32 RightWheel_PositionInMM
int16 RightWheel_RPM
int32 Laser_Encoder
int16 Laser_RPM
int8 FuelPercent
bool ChargingActive
bool ChargingEnabled
bool ConfidentOnFuel
bool OnReservedFuel
bool EmptyFuel
bool BatteryFailure

================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data 
# in a particular coordinate frame.
# 
# sequence ID: consecutively increasing ID 
uint32 seq
#Two-integer timestamp that is expressed as:
# * stamp.secs: seconds (stamp_secs) since epoch
# * stamp.nsecs: nanoseconds since stamp_secs
# time-handling sugar is provided by the client library
time stamp
#Frame this data is associated with
# 0: no frame
# 1: global frame
string frame_id

"""
  __slots__ = ['header','WallSensorInMM','BatteryVoltageInmV','LeftDropInMM','RightDropInMM','RightMagSensor','LeftMagSensor','SNSR_DC_JACK_CONNECT','SNSR_DUSTBIN_IS_IN','SNSR_LEFT_WHEEL_EXTENDED','SNSR_RIGHT_WHEEL_EXTENDED','LSIDEBIT','LFRONTBIT','RSIDEBIT','RFRONTBIT','BTN_SOFT_KEY','BTN_SCROLL_UP','BTN_SCROLL_DOWN','BTN_START','BTN_BACK','LeftWheel_Encoder','LeftWheel_PositionInMM','LeftWheel_RPM','RightWheel_Encoder','RightWheel_PositionInMM','RightWheel_RPM','Laser_Encoder','Laser_RPM','FuelPercent','ChargingActive','ChargingEnabled','ConfidentOnFuel','OnReservedFuel','EmptyFuel','BatteryFailure']
  _slot_types = ['std_msgs/Header','int16','int16','int16','int16','int8','int8','bool','bool','bool','bool','bool','bool','bool','bool','bool','bool','bool','bool','bool','int32','int32','int16','int32','int32','int16','int32','int16','int8','bool','bool','bool','bool','bool','bool']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       header,WallSensorInMM,BatteryVoltageInmV,LeftDropInMM,RightDropInMM,RightMagSensor,LeftMagSensor,SNSR_DC_JACK_CONNECT,SNSR_DUSTBIN_IS_IN,SNSR_LEFT_WHEEL_EXTENDED,SNSR_RIGHT_WHEEL_EXTENDED,LSIDEBIT,LFRONTBIT,RSIDEBIT,RFRONTBIT,BTN_SOFT_KEY,BTN_SCROLL_UP,BTN_SCROLL_DOWN,BTN_START,BTN_BACK,LeftWheel_Encoder,LeftWheel_PositionInMM,LeftWheel_RPM,RightWheel_Encoder,RightWheel_PositionInMM,RightWheel_RPM,Laser_Encoder,Laser_RPM,FuelPercent,ChargingActive,ChargingEnabled,ConfidentOnFuel,OnReservedFuel,EmptyFuel,BatteryFailure

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(NeatoSensors, self).__init__(*args, **kwds)
      #message fields cannot be None, assign default values for those that are
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.WallSensorInMM is None:
        self.WallSensorInMM = 0
      if self.BatteryVoltageInmV is None:
        self.BatteryVoltageInmV = 0
      if self.LeftDropInMM is None:
        self.LeftDropInMM = 0
      if self.RightDropInMM is None:
        self.RightDropInMM = 0
      if self.RightMagSensor is None:
        self.RightMagSensor = 0
      if self.LeftMagSensor is None:
        self.LeftMagSensor = 0
      if self.SNSR_DC_JACK_CONNECT is None:
        self.SNSR_DC_JACK_CONNECT = False
      if self.SNSR_DUSTBIN_IS_IN is None:
        self.SNSR_DUSTBIN_IS_IN = False
      if self.SNSR_LEFT_WHEEL_EXTENDED is None:
        self.SNSR_LEFT_WHEEL_EXTENDED = False
      if self.SNSR_RIGHT_WHEEL_EXTENDED is None:
        self.SNSR_RIGHT_WHEEL_EXTENDED = False
      if self.LSIDEBIT is None:
        self.LSIDEBIT = False
      if self.LFRONTBIT is None:
        self.LFRONTBIT = False
      if self.RSIDEBIT is None:
        self.RSIDEBIT = False
      if self.RFRONTBIT is None:
        self.RFRONTBIT = False
      if self.BTN_SOFT_KEY is None:
        self.BTN_SOFT_KEY = False
      if self.BTN_SCROLL_UP is None:
        self.BTN_SCROLL_UP = False
      if self.BTN_SCROLL_DOWN is None:
        self.BTN_SCROLL_DOWN = False
      if self.BTN_START is None:
        self.BTN_START = False
      if self.BTN_BACK is None:
        self.BTN_BACK = False
      if self.LeftWheel_Encoder is None:
        self.LeftWheel_Encoder = 0
      if self.LeftWheel_PositionInMM is None:
        self.LeftWheel_PositionInMM = 0
      if self.LeftWheel_RPM is None:
        self.LeftWheel_RPM = 0
      if self.RightWheel_Encoder is None:
        self.RightWheel_Encoder = 0
      if self.RightWheel_PositionInMM is None:
        self.RightWheel_PositionInMM = 0
      if self.RightWheel_RPM is None:
        self.RightWheel_RPM = 0
      if self.Laser_Encoder is None:
        self.Laser_Encoder = 0
      if self.Laser_RPM is None:
        self.Laser_RPM = 0
      if self.FuelPercent is None:
        self.FuelPercent = 0
      if self.ChargingActive is None:
        self.ChargingActive = False
      if self.ChargingEnabled is None:
        self.ChargingEnabled = False
      if self.ConfidentOnFuel is None:
        self.ConfidentOnFuel = False
      if self.OnReservedFuel is None:
        self.OnReservedFuel = False
      if self.EmptyFuel is None:
        self.EmptyFuel = False
      if self.BatteryFailure is None:
        self.BatteryFailure = False
    else:
      self.header = std_msgs.msg.Header()
      self.WallSensorInMM = 0
      self.BatteryVoltageInmV = 0
      self.LeftDropInMM = 0
      self.RightDropInMM = 0
      self.RightMagSensor = 0
      self.LeftMagSensor = 0
      self.SNSR_DC_JACK_CONNECT = False
      self.SNSR_DUSTBIN_IS_IN = False
      self.SNSR_LEFT_WHEEL_EXTENDED = False
      self.SNSR_RIGHT_WHEEL_EXTENDED = False
      self.LSIDEBIT = False
      self.LFRONTBIT = False
      self.RSIDEBIT = False
      self.RFRONTBIT = False
      self.BTN_SOFT_KEY = False
      self.BTN_SCROLL_UP = False
      self.BTN_SCROLL_DOWN = False
      self.BTN_START = False
      self.BTN_BACK = False
      self.LeftWheel_Encoder = 0
      self.LeftWheel_PositionInMM = 0
      self.LeftWheel_RPM = 0
      self.RightWheel_Encoder = 0
      self.RightWheel_PositionInMM = 0
      self.RightWheel_RPM = 0
      self.Laser_Encoder = 0
      self.Laser_RPM = 0
      self.FuelPercent = 0
      self.ChargingActive = False
      self.ChargingEnabled = False
      self.ConfidentOnFuel = False
      self.OnReservedFuel = False
      self.EmptyFuel = False
      self.BatteryFailure = False

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_struct_3I.pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_struct_4h2b13B2ih2ihihb6B.pack(_x.WallSensorInMM, _x.BatteryVoltageInmV, _x.LeftDropInMM, _x.RightDropInMM, _x.RightMagSensor, _x.LeftMagSensor, _x.SNSR_DC_JACK_CONNECT, _x.SNSR_DUSTBIN_IS_IN, _x.SNSR_LEFT_WHEEL_EXTENDED, _x.SNSR_RIGHT_WHEEL_EXTENDED, _x.LSIDEBIT, _x.LFRONTBIT, _x.RSIDEBIT, _x.RFRONTBIT, _x.BTN_SOFT_KEY, _x.BTN_SCROLL_UP, _x.BTN_SCROLL_DOWN, _x.BTN_START, _x.BTN_BACK, _x.LeftWheel_Encoder, _x.LeftWheel_PositionInMM, _x.LeftWheel_RPM, _x.RightWheel_Encoder, _x.RightWheel_PositionInMM, _x.RightWheel_RPM, _x.Laser_Encoder, _x.Laser_RPM, _x.FuelPercent, _x.ChargingActive, _x.ChargingEnabled, _x.ConfidentOnFuel, _x.OnReservedFuel, _x.EmptyFuel, _x.BatteryFailure))
    except struct.error as se: self._check_types(se)
    except TypeError as te: self._check_types(te)

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    try:
      if self.header is None:
        self.header = std_msgs.msg.Header()
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _struct_3I.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.frame_id = str[start:end].decode('utf-8')
      else:
        self.header.frame_id = str[start:end]
      _x = self
      start = end
      end += 56
      (_x.WallSensorInMM, _x.BatteryVoltageInmV, _x.LeftDropInMM, _x.RightDropInMM, _x.RightMagSensor, _x.LeftMagSensor, _x.SNSR_DC_JACK_CONNECT, _x.SNSR_DUSTBIN_IS_IN, _x.SNSR_LEFT_WHEEL_EXTENDED, _x.SNSR_RIGHT_WHEEL_EXTENDED, _x.LSIDEBIT, _x.LFRONTBIT, _x.RSIDEBIT, _x.RFRONTBIT, _x.BTN_SOFT_KEY, _x.BTN_SCROLL_UP, _x.BTN_SCROLL_DOWN, _x.BTN_START, _x.BTN_BACK, _x.LeftWheel_Encoder, _x.LeftWheel_PositionInMM, _x.LeftWheel_RPM, _x.RightWheel_Encoder, _x.RightWheel_PositionInMM, _x.RightWheel_RPM, _x.Laser_Encoder, _x.Laser_RPM, _x.FuelPercent, _x.ChargingActive, _x.ChargingEnabled, _x.ConfidentOnFuel, _x.OnReservedFuel, _x.EmptyFuel, _x.BatteryFailure,) = _struct_4h2b13B2ih2ihihb6B.unpack(str[start:end])
      self.SNSR_DC_JACK_CONNECT = bool(self.SNSR_DC_JACK_CONNECT)
      self.SNSR_DUSTBIN_IS_IN = bool(self.SNSR_DUSTBIN_IS_IN)
      self.SNSR_LEFT_WHEEL_EXTENDED = bool(self.SNSR_LEFT_WHEEL_EXTENDED)
      self.SNSR_RIGHT_WHEEL_EXTENDED = bool(self.SNSR_RIGHT_WHEEL_EXTENDED)
      self.LSIDEBIT = bool(self.LSIDEBIT)
      self.LFRONTBIT = bool(self.LFRONTBIT)
      self.RSIDEBIT = bool(self.RSIDEBIT)
      self.RFRONTBIT = bool(self.RFRONTBIT)
      self.BTN_SOFT_KEY = bool(self.BTN_SOFT_KEY)
      self.BTN_SCROLL_UP = bool(self.BTN_SCROLL_UP)
      self.BTN_SCROLL_DOWN = bool(self.BTN_SCROLL_DOWN)
      self.BTN_START = bool(self.BTN_START)
      self.BTN_BACK = bool(self.BTN_BACK)
      self.ChargingActive = bool(self.ChargingActive)
      self.ChargingEnabled = bool(self.ChargingEnabled)
      self.ConfidentOnFuel = bool(self.ConfidentOnFuel)
      self.OnReservedFuel = bool(self.OnReservedFuel)
      self.EmptyFuel = bool(self.EmptyFuel)
      self.BatteryFailure = bool(self.BatteryFailure)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_struct_3I.pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_struct_4h2b13B2ih2ihihb6B.pack(_x.WallSensorInMM, _x.BatteryVoltageInmV, _x.LeftDropInMM, _x.RightDropInMM, _x.RightMagSensor, _x.LeftMagSensor, _x.SNSR_DC_JACK_CONNECT, _x.SNSR_DUSTBIN_IS_IN, _x.SNSR_LEFT_WHEEL_EXTENDED, _x.SNSR_RIGHT_WHEEL_EXTENDED, _x.LSIDEBIT, _x.LFRONTBIT, _x.RSIDEBIT, _x.RFRONTBIT, _x.BTN_SOFT_KEY, _x.BTN_SCROLL_UP, _x.BTN_SCROLL_DOWN, _x.BTN_START, _x.BTN_BACK, _x.LeftWheel_Encoder, _x.LeftWheel_PositionInMM, _x.LeftWheel_RPM, _x.RightWheel_Encoder, _x.RightWheel_PositionInMM, _x.RightWheel_RPM, _x.Laser_Encoder, _x.Laser_RPM, _x.FuelPercent, _x.ChargingActive, _x.ChargingEnabled, _x.ConfidentOnFuel, _x.OnReservedFuel, _x.EmptyFuel, _x.BatteryFailure))
    except struct.error as se: self._check_types(se)
    except TypeError as te: self._check_types(te)

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    try:
      if self.header is None:
        self.header = std_msgs.msg.Header()
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _struct_3I.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.frame_id = str[start:end].decode('utf-8')
      else:
        self.header.frame_id = str[start:end]
      _x = self
      start = end
      end += 56
      (_x.WallSensorInMM, _x.BatteryVoltageInmV, _x.LeftDropInMM, _x.RightDropInMM, _x.RightMagSensor, _x.LeftMagSensor, _x.SNSR_DC_JACK_CONNECT, _x.SNSR_DUSTBIN_IS_IN, _x.SNSR_LEFT_WHEEL_EXTENDED, _x.SNSR_RIGHT_WHEEL_EXTENDED, _x.LSIDEBIT, _x.LFRONTBIT, _x.RSIDEBIT, _x.RFRONTBIT, _x.BTN_SOFT_KEY, _x.BTN_SCROLL_UP, _x.BTN_SCROLL_DOWN, _x.BTN_START, _x.BTN_BACK, _x.LeftWheel_Encoder, _x.LeftWheel_PositionInMM, _x.LeftWheel_RPM, _x.RightWheel_Encoder, _x.RightWheel_PositionInMM, _x.RightWheel_RPM, _x.Laser_Encoder, _x.Laser_RPM, _x.FuelPercent, _x.ChargingActive, _x.ChargingEnabled, _x.ConfidentOnFuel, _x.OnReservedFuel, _x.EmptyFuel, _x.BatteryFailure,) = _struct_4h2b13B2ih2ihihb6B.unpack(str[start:end])
      self.SNSR_DC_JACK_CONNECT = bool(self.SNSR_DC_JACK_CONNECT)
      self.SNSR_DUSTBIN_IS_IN = bool(self.SNSR_DUSTBIN_IS_IN)
      self.SNSR_LEFT_WHEEL_EXTENDED = bool(self.SNSR_LEFT_WHEEL_EXTENDED)
      self.SNSR_RIGHT_WHEEL_EXTENDED = bool(self.SNSR_RIGHT_WHEEL_EXTENDED)
      self.LSIDEBIT = bool(self.LSIDEBIT)
      self.LFRONTBIT = bool(self.LFRONTBIT)
      self.RSIDEBIT = bool(self.RSIDEBIT)
      self.RFRONTBIT = bool(self.RFRONTBIT)
      self.BTN_SOFT_KEY = bool(self.BTN_SOFT_KEY)
      self.BTN_SCROLL_UP = bool(self.BTN_SCROLL_UP)
      self.BTN_SCROLL_DOWN = bool(self.BTN_SCROLL_DOWN)
      self.BTN_START = bool(self.BTN_START)
      self.BTN_BACK = bool(self.BTN_BACK)
      self.ChargingActive = bool(self.ChargingActive)
      self.ChargingEnabled = bool(self.ChargingEnabled)
      self.ConfidentOnFuel = bool(self.ConfidentOnFuel)
      self.OnReservedFuel = bool(self.OnReservedFuel)
      self.EmptyFuel = bool(self.EmptyFuel)
      self.BatteryFailure = bool(self.BatteryFailure)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill

_struct_I = genpy.struct_I
_struct_4h2b13B2ih2ihihb6B = struct.Struct("<4h2b13B2ih2ihihb6B")
_struct_3I = struct.Struct("<3I")
